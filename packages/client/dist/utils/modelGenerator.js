import fs from 'fs';
import path from 'path';
export class ModelGenerator {
    outputPath;
    models;
    typeMapping = {
        string: 'string',
        number: 'number',
        boolean: 'boolean',
        date: 'Date',
    };
    constructor(outputPath) {
        this.outputPath = outputPath;
        this.models = new Map();
        this.ensureDirectoryExists();
    }
    ensureDirectoryExists() {
        const dir = path.dirname(this.outputPath);
        if (!fs.existsSync(dir)) {
            fs.mkdirSync(dir, { recursive: true });
        }
    }
    addModel(definition) {
        this.models.set(definition.name, definition);
    }
    generateTypeForModel(definition) {
        const fields = Object.entries(definition.fields).map(([fieldName, fieldConfig]) => {
            const type = this.typeMapping[fieldConfig.type];
            const isRequired = fieldConfig.required !== false;
            return `  ${fieldName}${isRequired ? '' : '?'}: ${type};`;
        });
        // Adiciona campos padrão que todo modelo terá
        const defaultFields = ['  id: string;', '  createdAt: Date;', '  updatedAt: Date;'];
        return `export type ${definition.name} = {
${[...defaultFields, ...fields].join('\n')}
};

export type Create${definition.name}Input = {
${fields.map(field => field.replace(';', '?;')).join('\n')}
};

export type Update${definition.name}Input = Partial<Create${definition.name}Input>;`;
    }
    generateTypes() {
        let content = `// This file is auto-generated. Do not edit it manually.
// Generated by Prisloc Model Generator

`;
        // Adiciona imports necessários
        content += `import { Prisloc } from './index';\n\n`;
        // Gera os tipos para cada modelo
        for (const [_, definition] of this.models) {
            content += this.generateTypeForModel(definition) + '\n\n';
        }
        // Gera o tipo PrislocClient com todos os modelos
        content += `export type PrislocClient = {
${Array.from(this.models.keys())
            .map(modelName => `  ${modelName.toLowerCase()}: ${modelName}Model;`)
            .join('\n')}
};

`;
        // Gera interfaces para os modelos
        for (const [modelName] of this.models) {
            content += `export interface ${modelName}Model {
  create(data: Create${modelName}Input): Promise<${modelName}>;
  findMany(options?: {
    where?: Partial<${modelName}>;
    orderBy?: { [K in keyof ${modelName}]?: 'asc' | 'desc' };
    skip?: number;
    take?: number;
  }): Promise<${modelName}[]>;
  findUnique(where: Partial<${modelName}>): Promise<${modelName} | null>;
  update(where: Partial<${modelName}>, data: Update${modelName}Input): Promise<${modelName}>;
  delete(where: Partial<${modelName}>): Promise<${modelName}>;
}\n\n`;
        }
        fs.writeFileSync(this.outputPath, content);
    }
}
